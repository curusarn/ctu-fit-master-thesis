% arara: xelatex
% arara: xelatex
% arara: xelatex

% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks

\documentclass[thesis=M,english]{FITthesis}[2012/10/20]

\usepackage[utf8]{inputenc}

\usepackage{graphicx} %graphics files inclusion
% \usepackage{subfig} %subfigures
% \usepackage{amsmath} %advanced maths
% \usepackage{amssymb} %additional math symbols

\usepackage{dirtree} %directory tree visualisation

% ADDED BY ME
%\usepackage{blindtext} % lorem ipsum
%\definecolor{mygray}{gray}{0.6}
%\newcommand{\blind}[1][1]{\textcolor{mygray}{\Blindtext[#1][1]}}

\newcommand{\blind}[1][1]{}

% ALSO ADDED BY ME
\usepackage{todonotes} 
\usepackage{multicol}

\newcommand{\todotext}[1]{\textcolor{red}{\textbf{[[#1]]}}}
\newcommand{\redtext}[1]{\textcolor{red}{[[#1]]}} 


\setlength{\fboxsep}{0.005pt}
\newcommand{\tmpframe}[1]{\fbox{#1}}
\renewcommand{\tmpframe}[1]{#1}
\newcommand{\permanentframe}[1]{\fbox{#1}}
\newcommand{\noframe}[1]{#1}


\let\myCite\cite
\renewcommand\cite{\unskip~\myCite}
\let\myRef\ref
\renewcommand\ref{\unskip~\myRef}


\newcommand\hatx{\^{}}
\newcommand{\hatxxx}{\hatx\hatx\hatx}

% list of acronyms
%\usepackage[acronym,nonumberlist,toc,numberedsection=autolabel,nomain]{glossaries}
\iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
%\makeglossaries

\newcommand{\tg}{\mathop{\mathrm{tg}}} %cesky tangens
\newcommand{\cotg}{\mathop{\mathrm{cotg}}} %cesky cotangens

% LB
% \setlength{\parskip}{0em}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
\department{Department of theoretical computer science}
\title{Contextual Shell History}
\authorGN{Šimon} %author's given name/names
\authorFN{Let} %author's surname
\authorWithDegrees{Bc. Šimon Let} %author's name with academic degrees
\author{Šimon Let} %author's name without academic degrees
\supervisor{Ing. Lukáš Bařinka}

\acknowledgements{I would like to thank my supervisor Ing. Lukáš Bařinka for his guidance and advice. His insights and expertise shaped this work significantly. 

Next, my thanks goes to my colleagues and friends for their valuable feedback. They helped me spot my personal biases and assumptions rooted in my personal shell workflows. 

I am grateful for the trust of hundreds of people who downloaded this project. I would also like to thank all GitHub users who submitted issues and pull requests to the project.

I want to thank Installfest conference organizers for the opportunity to give a talk and to demo this project on Installfest.  

Finally, I would like to thank my family for their support during writing this thesis and trough my whole studies.
}
\abstractCS{I dnes zůstává příkazová řádka populárním způsob jak ovládat počítač. Historie shellu umožňuje lidem snadno opakovat předchozí příkazy což zvyšuje jejich 
produktivitu.
Způsob jakým lidé používají shell závisí na kontextu jako je třeba současný adresář. V této práci chceme využít dostupný kontext ke zlepšení standartní historie shellu.

%Even nowadays, command line is a popular way to interact with computers. Shell history allows people to reuse previous commands which increases productivity. 
%The way people use shell changes based on context such as current directory. In this work, we intend to use additional context to enhance the standard shell history.

Analyzujeme funkce standartní historie a to jak je lidé používají. Identifikujeme interaktivní zpětné vyhledávání jako neefektivní mechanismus standartní historie vhodný pro náhradu.   

%We analyze standard history features and how people use them. We identify reverse search as inefficient standard feature we need to redesign.

Prozkoumáním existujících nástrojů historie shellu najdeme nástroje, které řeší problémy s interaktivním zpětným vyhledáváním. Nacházíme také kontextové nástroje historie shellu, které ale nepřináší uživateli velké zlepšení.

%By exploring existing history tools we find tools that address the issues of reverse search. We also find contextual history tools that do not bring much value to the user. 

Navrhujeme systém historie shellu, který přináší výhody existujících nekontextových nástrojů historie. Zároveň náš návrh používá kontext k dalšímu zlepšení funkcí historie shellu.

%We design a history system that matches the improvement of state-of-the-art non-contextual history tools; Plus, our design uses context to further enhance the capabilities of the shell history.

Implementujeme podstatnou část našeho návrhu. Naše řešení zaznamenává historii shellu s kontextem. Terminálová aplikace vyhledává v historii a zobrazuje relevantní výsledky na základě současného kontextu. 

%We implement a core parts of the design. It records shell history with context. A fullscreen terminal app searches the history and returns relevant results based on current context.

Na základě dát o používání od našich uživatelů porovnáváme naše řešení s populárním existujícím nástrojem pro vyhledávání v historii -- Hstr. Naše řešení v průměru podává podobný nebo lepší výkon než Hstr.

%Based on usage data from some of our users, we compare our solution with one of the state-of-the-art history tools -- Hstr.
%Our solution on average performs similarly or better than Hstr.

Existuje mnoho situací, kde naše řešení překonává Hstr. Uživatel při vyhledávání potřebuje méně znalosti a musí méně psát. Naše řešení v průměru šetří uživateli více napsaných znaků.

%We found many situations where our solution outperforms Hstr. It requires less knowledge and less typing when searching. Our solution on average saves more typed chars to the user. 

Naše řešení bylo za posledních pět měsíců nainstalováno přes 600 krát. Někteří naši uživatelé dříve používali Hstr a naše aplikace pokrývá všechny jejich předchozí potřeby. Zpětná vazba kterou jsme dostali od komunity je z velké části pozitivní.

%Our solution has been installed over 600 times in last five months. Some of our users previously used Hstr and our application covers all of their previous workflows. We have received overwhelmingly positive feedback from the community.
}

\abstractEN{Even nowadays, command line is a popular way to interact with computers. Shell history allows people to reuse previous commands which increases productivity. 
The way people use shell changes based on context such as current directory. In this work, we intend to use available context to enhance the standard shell history.

% e describe target users for our system and typical workflows people perform. Based on the workflows w
We analyze standard history features and how people use them. We identify reverse search as inefficient standard feature we need to redesign.

By exploring existing history tools we find tools that address the issues of reverse search. We also find out that existing contextual history tools do not bring much value to the user. 
%Useful contextual history tools need to match the improvements provided by non-contextual tools.
 
We design a history system that matches the improvement of state-of-the-art non-contextual history tools; Plus it uses context to further enhance the capabilities of the shell history.

We implement a core parts of the design. It records shell history with context. A fullscreen terminal application searches the history and returns relevant results based on current context.

Based on usage data from some of our users, we compare our solution with one of the state-of-the-art history tools -- Hstr.
Our solution on average performs similarly or better than Hstr.

There are many situations where our solution outperforms Hstr. It requires less knowledge and less typing when searching. Our solution on average saves more typed chars to the user. 

Our solution has been installed over 600 times in last five months. Some of our users previously used Hstr and our application covers all of their previous workflows. We have received overwhelmingly positive feedback from the community.

}
\placeForDeclarationOfAuthenticity{Prague} %where you have signed the declaration
\keywordsCS{Shell, Příkazová řádka, Historie shellu, Nástroje produktivity}
\keywordsEN{Shell, Command line, Shell history, Productivity tools}
\declarationOfAuthenticityOption{1} %select as appropriate, according to the desired license
% \website{https://github.com/curusarn/master-thesis} %optional URL (remove entirely if you have no URL for this thesis) TODO: put the thesis up

\begin{document}

%\newacronym{GUI}{GUI}{Graphical User Interface}
%\newacronym{CLI}{CLI}{Command Line Interface}
%\newacronym{GNU}{GNU}{GNU's Not Unix!}
\begin{introduction}



Classic command line interfaces were mostly replaced by GUIs in consumer software \cite{norman2007ui}. However, among IT professionals and enthusiasts, CLIs and shells are a popular way to interact with computers.\footnote{CLIs and shells are active topics on websites that are popular among developers. Specifically, GitHub Topics, Stack Overflow, and Super User all register notable activity under topics/tags about CLIs, Bash, and Zsh.} 
%CLIs are generally not replaceable by GUIs. GUIs do not work well when the number of available actions is high \cite{norman2007ui}. 

Shell history enables shell users to reuse previously entered command line submissions.
There are many people who care about shell history tools.\footnote{We have sparked a wave of reactions by asking people about what shell history tools they are using.\cite{twitter-thread}}

Shells like Bash and Zsh were initially released around year 1990. History features in these shells have not seen many improvements since beginning of the millennium. In this work, we analyze the standard history mechanisms to find how they could be improved.

People use shell differently in different situations. For example, some directories contain projects and people might use different commands based on which project they are working on. We think that we could use directories and more additional information to improve the capabilities of shell history. 

We focus on Unix-based operating systems because more than half of all developers use them\footnote{According to \cite{stackoverflow2019devsurvey}, 25.6\% and 26.8\% of developers use Linux and MacOS respectively.}. 
Default shell on GNU/Linux is Bash \cite{ramey1994gnubash} and default shell on MacOS is Zsh\footnote{According to \cite{apple2019zsh}, default shell in MacOS is Zsh since October 2019.}. Because of that, we focus on these two popular shells.

We examine standard history features and what issues people encounter when using them. We introduce target users and formulate typical shell history workflows. We explore existing history tools and how they improve standard shell history. Then, we design a new contextual history system based on our analysis. We implement core parts of the designed system. Finally, we test the system using data we collect from our users. Based on that, we draw conclusion about this work.

\paragraph{Defined terms}

\redtext{should we define the terms here?}

To avoid confusion through out this work, we define following terms:

\begin{itemize}
    \item Command line entry $=$ the contents of the command line submitted by the user
    \item Command stub $=$ the first word of the command line entry
    \item History entry and command line submissions are sometimes used instead of command line entry.
\end{itemize}

\end{introduction}

% \begin{verbatim}
% ____5___10___15___20___25___30___35___40___45___50___55___60__64
% \end{verbatim}
% The page is 64 verbatim characters wide

\input{main_analysis}

\input{main_design}

\input{main_implementation}

\input{main_testing}

\begin{conclusion}

\redtext{Intro the problem, explain why we solved it and THEN describe how}



We have described shell history features available in current standard shells and pointed out their disadvantages. 
We have described the target users of our shell history tool. Based on shell history we collected we have formulated typical workflows that accomplish different tasks using shell history. We have provided a detailed explanation of these workflows pointing out issues with standard shell history mechanisms. As the main finding, we have identified reverse search as very inefficient history feature that is worth redesigning.

We have explored what popular history tools are available. We have found state-of-the-art non-contextual history tools that provide major improvement over standard history by replacing reverse search. These tools address the specific issues of reverse search we identified. We found contextual history tools that are based on appealing ideas; These tools however, do not match the improvements provided by the state-of-the-art non-contextual history tools. We have described how available contextual information relates to ways people use shell. \redtext{TODO: shorten analysis above as necessary}


% design

Based on our previous analysis, we have designed a history system. The design is a result of iterative process that involved feedback from users. Our design matches the improvements of the state-of-the-art non-contextual history tools. Furthermore, it uses context to enhance the capabilities of the shell history. The design was tested to make sure that it fulfills all set requirements. 

% implementation

We have implemented a significant portion of the design. The working solution records shell history with context and usage. It features a fullscreen terminal application that searches shell history and shows relevant results based on current context. Without any search query the application offers history entries from current context. 

% evaluation/testing


We have evaluated the performance of the search application and compared it with both state-of-the-art history tool and standard builtin history search mechanism. 
We have suggested metrics and used them to compare our solution with state-of-the-art history searching tool -- Hstr \cite{toolshstr}.
The average performance of our history searching application is either similar or better than Hstr. 

We have found real life situations where our solution provides significant advantage over both standard reverse search and Hstr.
Our solution enables the user to search with significantly less knowledge and typing. Furthermore, our search application on average saves more typed characters to the user. 
We have concluded that contextual search is a great default because it offers new possibilities without degrading the average performance.


As a result of feedback of our users, we have added several features to the search application. Notably, users can switch between default contextual search and non-contextual search. This is great for specific situations where using context does not bring value.

Since the release of the first prototype the search application has been installed over 600 times. The project has over 250 stars on GitHub. The feedback we have received is overwhelmingly positive. We have also presented one of the first versions of the application on Installfest conference. \cite{installfest-talk}\cite{installfest} 

Right now, we want to encourage you, the reader, to try out the project for yourself. You can find installation instructions on the GitHub page of the project: \url{https://github.com/curusarn/resh} %\cite{resh-github-homepage}


\paragraph{Future work}

Our work implements the core functionality of the designed history system. However, there are parts of the design that should be implemented because they provide considerable value to the users.

One part of the design we want to point out is synchronization.
Implementing the synchronization connectors for the daemon would enable history searching across devices. It would also make the stored history replicated which could prevent potential data loss.

Outside of the things we have included in the design, we suggest an improvement for our search application based on existing research. According to \cite{greenberg1993computer}, history entries that were already retrieved should be easier retrieve in the future. The scoring function should be modified to include this extra factor. 

Additionally, we propose a topic for future research. Using machine learning techniques and context to provide Autosuggestions tailored to the user is a promising topic for a thesis.   

More research should be done to explore relationships between history entries. Exploring how terminal sessions and sequences of history entries relate to workflows of people could bring useful insights. These insights could be used to improve history searching tools.

\end{conclusion}

\bibliographystyle{iso690.bst}
\bibliography{ref}

\appendix

%\printglossaries

\chapter{Contents of attached medium}\label{app:SDcontent}

\todotext{TODO: Visualise the contents of enclosed media. Use of dirtree is recommended. Note that directories src and text with appropriate contents are mandatory.}


\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{the file with CD contents description}.
		.1 data\DTcomment{the data files directory}.
		.2 graphs\DTcomment{the directory of graphs of experiments}.
		.3 *.eps\DTcomment{the B/W graphs}.
		.3 *.png\DTcomment{the color graphs}.
		.3 *.dat\DTcomment{the graphs data files}.
		.1 exe\DTcomment{the directory with executable WBDCM program}.
		.2 wbdcm\DTcomment{the WBDCM program executable (UNIX)}.
		.2 wbdcm.exe\DTcomment{the WBDCM program executable (Windows)}.
		.1 src\DTcomment{the directory of source codes}.
		.2 wbdcm\DTcomment{the directory of WBDCM program}.
		.3 Makefile\DTcomment{the makefile of WBDCM program (UNIX)}.
		.2 thesis\DTcomment{the directory of \LaTeX{} source codes of the thesis}.
		.3 figures\DTcomment{the thesis figures directory}.
		.3 *.tex\DTcomment{the \LaTeX{} source code files of the thesis}.
		.1 text\DTcomment{the thesis text directory}.
		.2 thesis.pdf\DTcomment{the Diploma thesis in PDF format}.
		.2 thesis.ps\DTcomment{the Diploma thesis in PS format}.
	}
\end{figure}

\chapter{}\label{app:extras}

\redtext{This should not be empty}

\newpage
\section{Sequential structure of command usage}\label{seq-app}

Figure \ref{seq-graph} shows sequential relationships between command stubs in shell usage of a single chosen user. 

The graph contains 41 most used commands. Each node represents a command stub and its is proportionate to the command stub frequency. Each vertex represents a transition probability from one command to the next one. Nodes \verb|_start_| and \verb|_end_| represent the beginning and end of terminal sessions.

We can see that there are significant dependencies between command stubs. Many commands repeat themselves with high probabilities. There are also high probability transitions between specific commands. For example, \verb|mkdir| is followed by \verb|cd| in 90\% of situations.

This is all interesting but is it usable in practice? Do people even recognize these sequential relationships in their shell usage?
We created a sequential graphs like this based on shell history of different users. When we show these graphs to the original user they always instantly recognize their history. Furthermore, people can immediately recognize and describe the workflows different sequences in the graph represent.

\begin{figure}

\tmpframe{\includegraphics[width=\linewidth]{figures/greenberg_new/graph_cmd-sequence_vit_41_0-1_crop.png}}
%\newline
%\newline
\centering
\begin{tabular}{|l|l|}
\hline
Vertex style & Transition probability            \\\hline
Regular/full     & 1.0 -- 0.3 (specified by labels) \\
Dashed      & 0.3 -- 0.2                         \\
Dotted      & 0.2 -- 0.1                         \\
\hline
\end{tabular}
%\caption{Sequential structure of command usage (legend).}
%\label{tab:seq-table}

\caption{Sequential structure of command usage.}
\label{seq-graph}
\end{figure}



\end{document}
