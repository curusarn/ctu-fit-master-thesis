
\chapter{Analysis}

In this chapter, we review the current state-of-the-art. 
We examine standard shell features because they represent both what people are used to and the starting point for our solution.

Because we want to know who we design for we introduce target users for our future design. We formulate shell history workflows based on shell usage data we have collected from several people. %Each workflow is described in detail. 
These workflows show us when standard shell history features work well and when there are issues. We explain the limitations and disadvantages of standard shell history features.

After that, we review existing history tools to see what problems they solve. We identify tools that address the issues of standard shell history features. We also find contextual history tools that do not bring much value to the user.

Then, we explore what contextual information is available in the shell. We break it down into multiple distinct categories. For each category, we describe how it relates to shell usage and how it could be useful in history tools.


\section{Standard shell history features}

In this section, we describe common standard shell history features of Bash\cite{bashman} and Zsh\cite{zshdocs}. Most of these features are enabled by default; The user can use them without configuring them first.
We cover following history features:

%For each of the features, we point out its advantages and disadvantages.
%The list of history features we cover the following:

\begin{itemize}
    \item Saving history entries
    \item History substitution
    \item Stepping through recent history
    \item Prefix search
    \item Reverse search
    \item Manual history filtering
\end{itemize}


\subsection{Saving history entries}

%First, we take a look at how command line entries are saved into history.
Whenever you submit a command line entry in shell, it is added to the history. Saved history entries are then available for future reuse. %We describe specific ways to access the history a bit later.

It is possible to configure shell to not save duplicate entries to history. 
In Zsh, we can also keep duplicates in history but prevent them from showing up when searching. 
There are options to prevent specific command line entries from being saved to history based on a user-specified pattern. %This is done using \verb|HISTIGNORE| option in Bash.

We can configure shell history to save the time of the execution alongside the history entry. In Zsh, it is also possible to record and save the duration of the execution.

\paragraph{Missing history entries}

When we execute a command line entry, we generally expect to be able to find it in history. This is not always the case. There are multiple reasons why executed command line entries can be missing in the shell history.

In Bash, simultaneous terminal sessions can overwrite the history of one another when it is being written to disk.\cite{bashman}\cite{bash-session-issues-1} This can be prevented by properly configuring the shell.

Shell history is not unlimited. We might not be able to find history entries simply because they are too old and our history size is too small. The size of shell history can be increased with configuration options. % \verb|HISTSIZE| and \verb|SAVEHIST| or \verb|HISTFILESIZE|.

\subsection{History substitution}

History substitution is a powerful feature that allows users to reuse previous history entries or their parts. 
For example, we can use \verb|!!| to repeat previous history entry and \verb|!$| to repeat its last argument. Executing a history entry based on its absolute or relative index can be done using \verb|!5| or \verb|!-2|, respectively.

The flexible notation of history substitution makes it possible to match recent history and perform substitutions on them. For instance, \verb|!cc| executes the last history entry that starts with \verb|cc|. An example of substitution is \verb|!!:s/foo/bar/|. It retrieves the previous history entry and replaces instances of \verb|foo| with \verb|bar|.

History substitution is powerful and flexible, but it is non-interactive. Users do not know what the substitution evaluates to until they execute it. For example, submitting \verb|!rm| could lead to irreversible losses.

It is possible to configure shell to show us the result of the substitution before executing it. Doing so, however, adds an extra step to each history substitution we perform. The additional required interaction can be very annoying in simple cases such as \verb|sudo !!|. A less invasive way to evaluate the substitutions before execution is \verb|magic-space|; It causes shell to expand substitutions after we press \verb|SPACE|.

\subsection{Stepping through recent history}

Repeatedly pressing \verb|ARROW_UP| gives us access to immediately previous history entries. Conversely, we can press \verb|ARROW_DOWN| to get back to the original command line. 

This is a quick and convenient way to access recent history entries. Instead of trying to remember the previous history entries, we can interactively step through them.

Quite obviously, this is not a great way to access older than recent history entries. Pressing \verb|ARROW_UP| many times and reading the results as they appear can take considerable amounts of time.

\subsection{Prefix search}

Prefix search works similarly as stepping through history using \verb|ARROW_UP|. It returns previous history entries that match the prefix we have already typed. 
This enables us to reuse recent and even older history entries based on their prefix. Prefix search is convenient in practice. For example, we can search for the previous \verb|git| commands which all most likely start with \verb|git| prefix.

When there is no prefix, prefix search works just like simple stepping through recent history. Because of that, it can be bound to arrow keys and used as a reasonable replacement for the default behavior. We can find prefix search configured this way in a popular Zsh configuration framework -- Oh-my-zsh\cite{toolsohmyzsh}.

In both Bash and Zsh, the prefix search is not configured by default. Before we people can start using it, they need to find out that it exists and configure it. This is one of many examples where we can see the importance of default configuration. Many people only know the default state of the shell because they never change the default configuration.

\subsection{Reverse search}

With the prefix search, we could only search the history by a prefix.
Reverse search allows us to interactively search for previous history entries based on any part of the command line entry. It can be activated using \verb|CTRL-R|.

In contrast to prefix search, the reverse search is available by default, and people seem to use it a lot. Reverse search is the most powerful interactive history search feature included in Bash and Zsh.

The reverse search might seem like the perfect way to search history. However, it does have its limitations. First, we cannot search using more than one word. In other words, the search query needs to be consecutive. Second, only one result is displayed at a time. We need to repeatedly press \verb|CTRL-R| to see more results.

Pointing out these limitations might seem like nitpicking. However, later we will see that they do limit the searching capabilities of reverse search significantly.


\subsection{Manual history filtering}

Shells offer built-in commands to print and control history. Built-in command \verb|history| and standard shell utilities can be used for powerful history searching.
For example, to search the history using two words and displays all matching results we can run following command line entry. 
\begin{verbatim}
    history | grep 'word1' | grep 'word2'
\end{verbatim}

Manually filtering history overcomes the limitations of reverse search. However, extra typing is necessary to complete the searches compared to interactive methods. Plus, unlike with reverse search, we cannot see the results update as we type the search query.


\section{Target users}

When designing any product, we need to make sure we know who the product is for. Shell history tools are no exception. To capture the target user-base, we are modeling two typical users as personas.


\subsection{Typical experienced shell user}

Experienced professional programmer \textit{Peter} develops, deploys, and operates back-end applications. The main languages he uses at work are C and C++. He has years of experience with developing on and for the Linux operating system. He is proficient in Bash, and he has written a few small shell scripts to increase his productivity.

His editor of choice is Vim. He has a sizable Vim configuration with multiple Vim plugins he collected over the years.

The shell he uses is Zsh with Oh-my-zsh \cite{toolsohmyzsh} shell configuration framework. On top of that, he maintains a set of his own custom options and aliases. He puts the resulting configurations on his machines. He does not change his configuration often, but he likes to be able to configure his shell and other tools he uses.

He often uses \verb|ssh| to log into remote machines. The remote machines are shared and have the default shell configuration. He keeps his shell and editor configuration somewhat similar to the default one because he does not want to constantly switch between very different environments. 

His daily shell workflows include complex commands with many long arguments and switching between many different projects. When coming back to a project, he sometimes cannot remember what command line entries he was using. He is familiar with Make, but he often forgets to create Makefiles for typical tasks in projects.

He makes use of interactive history features like reverse search and prefix search. However, he quite often uses manual history filtering.

\begin{verbatim}
    history | grep 'pattern1' | grep 'pattern2'     
\end{verbatim}

It is more powerful than the reverse search and sometimes it also feels more comfortable. Manual filtering allows him to search by more than one pattern and to see many of the matching results. 

\subsection{Typical novice shell user}

Junior data analyst \textit{Mark} has recently started his first job. He uses shell because he needs it at work. The primary language he uses is Python. 

The editor he uses is Visual Studio Code because it was recommended to him by a coworker. He likes that it suggests extensions to install based on files he is working with.

He is using Bash with the default configuration provided by Ubuntu distribution. Apart from that, he does not have any custom shell configuration. 

Since he does not have much experience with shells, he does not understands the shell configuration files. Because of that, he does not feel confident editing them. 

If he discovered or someone recommended a new shell tool to him, he would prefer an installation without the need to edit the shell configuration files. Additionally, he expects any programs and tools he installs to work out-of-the-box without requiring much configuration. 

There are shell history features he is not aware of such as history substitution and prefix search. He uses arrow keys to get recently submitted command line entries, and he presses \verb|CTRL-R| when looking for history entries further in the past. 


\section{Common shell history workflows}

Now that we know who our target users are, we can formulate common workflows for them. Workflows are formulated based on interviewing users, collected shell usage data\footnote{We have collected shell history and usage data from a few people with different experience levels. We used this data to find workflows and to determine how common different workflows are.}, and our experience with shells. 

Some of the workflows can be easily fulfilled using standard history features. Others are either difficult or impossible to complete. We describe and explain the issues people can encounter when using standard history features. 

\newpage
In the next few sections, we describe following workflows in detail:


\begin{itemize}
    \item Editing an immediately preceding history entry
    \item Blindly retrieving very recent history entries
    \item Retrieving recent history entries
    \item Editing retrieved history entries
    \item Repeating a sequence of history entries
    \item Searching with limited knowledge
    \item Searching with implicit context
\end{itemize}


\subsection{Editing an immediately preceding history entry}

In this first workflow, the user submits a command line entry but is not satisfied with the result. To fix that, he retrieves the immediately preceding history entry, modifies it, and executes it again. We will look at multiple example sequences of command line submissions for this workflow.

\begin{verbatim}
    wget https://pastebin.com/raw/EDELXNYp --silent
    wget https://pastebin.com/raw/EDELXNYp --quiet
\end{verbatim}
In this example, the user is trying to download a file from \verb|pastebin| using \verb|wget|. The first command ends with a non-zero exit status because \verb|--silent| is not an option of \verb|wget|. He presses \verb|ARROW_UP| to retrieve the previous command line entry, fixes the mistake, and presses \verb|ENTER| to submit the command line entry again. 

Using \verb|ARROW_UP| is efficient in situations when we need to either edit the end of the command line entry or append to it.
The next example shows a different case.

\begin{verbatim}
    apt-get install zsh
    sudo !!
\end{verbatim}

Here, the user wants to install the \verb|zsh| package. The command fails because superuser permissions are needed to install packages to the system. Instead of using interactive history features, the user uses history substitution \verb|!!| which repeats the previous history entry. 

By using \verb|!!| we can efficiently prepend or append to the previous command line entry. There are other history substitutions but \verb|!!| is by far the most commonly used one. 

So far, we only saw situations where the submitted command line ended with a non-zero exit status, and then the user fixed the error. This is not always the case because not all errors result in a non-zero exit code. Some errors are logical, and not all programs respect the convention of properly signaling errors. Additionally, users sometimes gradually change and develop a command line entry to make sure that each step of the process works as intended. This is shown in the example below.

\begin{verbatim}
    sort data.txt
    sort data.txt | uniq -c
    sort data.txt | uniq -c > data_processed.txt
\end{verbatim}

In this next example, we see how the user processes \verb|data.txt| file. In each step, he uses \verb|ARROW_UP| to retrieve the previous history entry and continues editing it. When he is satisfied with the result, he redirects the processed data into a file. 

This example shows that there is not always an explicit error that could be detected by the shell to predict that the user will retrieve the previous history entry. It also shows that the editing process can often be continuous.

We just saw multiple different situations in which people continue working on the same command. We also saw different approaches to retrieving previous history entries. It is worth noting that in all of these situations, the user relies on the order of the shell history. 

\subsection{Blindly retrieving very recent history entries}\label{workflow-blind-retrieval}

This second workflow is a retrieval and execution of a very recent history entry. Here, the user remembers the exact position of the history entry he wants to retrieve. An example of such workflow is running the following sequence of command line submissions.
\begin{verbatim}
    make build
    vim hello_world.c
    make build
\end{verbatim}
First, we use \verb|make| to build a project. Then we edit a file using \verb|vim|. After that, we press \verb|ARROW_UP| twice and press \verb|ENTER| to execute the retrieved history entry -- \verb|make build|. 


Consider, if we used a graphical editor or if we ran the editor from a different terminal. In such case, we would only have to press \verb|ARROW_UP| once but the workflow would essentially stay the same.

When retrieving very recent history entries the users often remember the exact position of the history entry; This means that they do not read the history entry that appears on the command line but they blindly execute it instead. This is an efficient workflow that shows us the importance of the order of recent history entries.

\subsection{Retrieving recent history entries}\label{workflow-recent-history-arrow-up}
The third workflow is a retrieval of history entry that is still recent, but the user no longer remembers the exact position in the history list. This means that the user needs to read the history entries as they appear to see if the desired entry was retrieved. An example sequence of command line entries for this workflow follows.

\begin{verbatim}
    systemctl start nginx.service
    systemctl status nginx.service
    tail /var/log/nginx/error.log
    nginx -t
    vim /etc/nginx/nginx.conf
    nginx -t
    systemctl start nginx.service
\end{verbatim}

In this example, the user is trying to start an Nginx \cite{reese2008nginx} web server. At first, the server does not start, and the command returns an error. The user quickly realizes that there is a syntactic error in the configuration file after checking it using \verb|nginx -t|. Then, the configuration is fixed using \verb|vim|, and the syntax is rechecked using \verb|nginx -t|. 

At this point, the user presses \verb|ARROW_UP| five or six times\footnote{It could take five or six depending on whether or not the user has history deduplication turned on.} to retrieve a recently executed command line entry \verb|systemctl start nginx.service|. Every time they press \verb|ARROW_UP| a single result appears, and they need to read it. There is no way to tell if the desired result is one press of a button away, three, or seven. % When the user presses \verb|ARROW_UP| too many times, they can show previous history entries by pressing \verb|ARROW_DOWN|.


% It seems that people experience the sunk cost fallacy\footnote{\redtext{TODO: describe?}} which combined with the lack of feedback from the system drives them to stick to the original plan -- pressing \verb|ARROW_UP|. 

You might think that people would not press \verb|ARROW_UP| five or six times and would rather use other history mechanisms.
However, the usage data we collected shows that even someone who claimed not to press \verb|ARROW_UP | excessively actually does so quite often. Pressing \verb|ARROW_UP| five times is more common than you would expect, and pressing it over ten times is rare, but it still happens. We also quite often saw people pressing \verb|ARROW_UP| too many times and then using \verb|ARROW_DOWN| to go back to previous history entries. We think that it is easy to overshoot when you only see one history entry at a time.

%\todo{we could include reasons why people do this but I don't think it's necessary/important (see drafts in comments)}

% 1-2 was the most common ... 5-6 quite common ... 8 - 10 rare 20 exceptions
% WHY: sunk cost fallacy + lack of feedback from the system
% WHY: people might not realize how far the entry is in the first place
% WHY: people do not want to "abandon the effort they have already put in" because anytime the result could be there

%It seems that in situations like this one people do remember the history entry well and perceive it as recent. This is why they chose to use 

\paragraph{Prefix search}

An efficient alternative way to fulfill the same workflow is to use the prefix search. To use prefix search, the user needs to remember the first word or at least the first few characters of the command line entry; This is likely since all the command line entries we are retrieving in this workflow are recent.

We will use the example with Nginx to compare using prefix search with the simple stepping through recent history. When using prefix search, the user types in a prefix -- \verb|systemctl| -- and presses \verb|ARROW_UP| twice to get to the desired history entry. In contrast, when only using \verb|ARROW_UP|, it took five or six presses to get to the history entry.

This might not seem like an improvement because we need to type the prefix before we start pressing \verb|ARROW_UP|. However, we have to realize that going through multiple history entries and reading them one by one requires a significant amount of time and effort compared to typing. 
This is a good example of how the number of keystrokes is not the only thing we should be taking into account. Generally speaking, shell history should save effort and time of its users. Retrieving previous history entries should be both mechanically and cognitively less demanding than typing them again.\cite{greenberg1993computer}

% REF(greenberg): Recurring inputs should be reentered more easily than the user's original entry, with the aim of reducing both physical tedium and the cognitive overhead of remembering past inputs. Reuse facilities should not be targeted only to experts, as they can help everyone.

% the prefix could be shorter e.g. "sys", "system" ... typing vs. effort required to decide how long/short prefix is sufficient

%\todotext{Is this ending good? - continue (check comments)}

% ADD(polished?): There is a vocal group of people with strong preference for prefix search. The rest of the people either do not know that prefix search exists, do not have it configured, or prefer plain \verb|ARROW_UP| possibly out of habit.
% NOTE: maybe this^ belongs earlier? (but maybe not)


\subsection{Editing retrieved history entries}

In the previous section, we saw a workflow where the user retrieved a recent history entry and executed it without any changes. Now, we look at a similar workflow. Here, the user retrieves a history entry, edits it, and then executes it again. Workflows with editing are a little less common than those with direct execution according to the usage data we collected. An example of a workflow with editing follows.

\begin{verbatim}
    curl --data "value=test" http://localhost:8080/submit
    git add pkg/submit/submit.go
    git commit --message "fix submit endpoint"
    git tag v2.4.0-rc.1
    git push
    git push --tags
    curl --data "value=test" http://test.example.com:8080/submit
\end{verbatim}


Here, the user is using \verb|curl| to test a server endpoint running locally at \verb|localhost:3000/submit|. After being done with the testing, he commits the changes, tags the version as a pre-release\footnote{Here "rc" in "v2.4.0-rc.1" version stands for release candidate which is sometimes used to mark pre-release versions.}, and pushes both commits and tags to the upstream. This triggers a CI pipeline that deploys the new version to the testing environment. The user wants to test that the endpoint also works there.

At this point, the user presses \verb|ARROW_UP| six times to get to the desired history entry.\footnote{Alternatively, he could also use prefix search which would be more efficient.} 
After retrieving the desired history entry, the user needs to edit it to change the server URL from \verb|localhost| to \verb|test.example.com|. He holds down \verb|ARROW_LEFT| for about a second, holds down \verb|DELETE| for about a second, types \verb|test.example.com|, and finally executes the changed command line entry. 

This seems a little tedious, but it is still more efficient than typing the whole command line entry from scratch. Instead of navigating by and deleting single characters, we could use \verb|CTRL+ARROW_LEFT| to navigate by words and \verb|ALT+BACKSPACE| to delete whole words; This would be faster and more efficient. %However, it seems that many people do not use the command line editing functions.\todo{TODO: Ask more people, so far more people use it than I expected}

This workflow shows us how people edit history entries after they retrieve them. We see that standard history mechanisms make it possible to edit history entries after retrieval. %Reverse search, which we did not see in any workflow yet, is not an exception. 
This is a useful property that we should include in our designs as well. 

\subsection{Repeating a sequence of history entries}\label{workflow-repeating-a-sequence}

In this workflow, the user has executed a sequence of command line entries. He wants to retrieve and repeat all the command line entries in the sequence. 
Consider the following example.

\begin{verbatim}
    gcc generate_dot.c -o generate_dot.out
    ./generate_dot.out > graph.dot
    dot -Tpng -ograph.png graph.dot
    feh graph.png
    gcc generate_dot.c -o generate_dot.out
    ./generate_dot.out > graph.dot
    dot -Tpng -ograph.png graph.dot
    feh graph.png
\end{verbatim}

In this example, we are editing the \verb|generate_dot.c| file in another window. In current terminal, we compile a source file \verb|generate_dot.c|, generate a graph in the DOT\cite{graphvizthedotlanguage} language, run Graphviz\cite{ellson2001graphviz} command \verb|dot| to generate an image, and finally use image viewer \verb|feh|\cite{toolsfeh} to display the resulting image.

% ALT (too long): After observing the resulting image, we edit the source file \verb|generate_dot.c| in another window.
After observing the image, we edit the source file \verb|generate_dot.c| in another window.


Now, we want to repeat the whole process of generating the graph and view the resulting image. To retrieve the \verb|gcc| history entry, we press \verb|ARROW_UP| four times. Retrieving the next \verb|./generate_dot.out| entry also takes four presses of \verb|ARROW_UP|. Similarly, we need four keypresses for each of \verb|dot| and \verb|feh| history entries. 

We need four keypresses every time because with each executed command line entry, we are pushing all the history entries further back in the history. We see that using \verb|ARROW_UP| to repeat a block of history entries is quite inefficient. 

There is another standard history mechanism we could use to repeat a block of history entries. 
Executing \verb|fc -4 -1| opens an editor with the last four history entries and then, closing the editor executes the commands. This, however, is quite cumbersome in practice, and not many people seem to use it. 


Repeating a sequence of history entries is not the most common workflow. However, it shows us the limits and inefficiencies of standard shell history.


\subsection{Searching with limited knowledge}\label{workflow-search-w-limited-knowledge}

In all the workflows we discussed so far, the user wanted to retrieve a fairly recent history entry. Now, we move on to workflows where the user searches for older history entries. In these workflows, the user's memory is often a limiting factor; Both the knowledge of shell history and the desired command line entry are limited.

Below, we see an example of such workflow. The upper part contains relevant history entries from history. In the bottom part, we see the command line entry the user wants to find. 

%This means that simply pressing \verb|ARROW_UP| is no longer an effective way to retrieve them.
% \redtext{We are going to look at multiple examples of workflow where the user searches for an older. We will discuss how the workflow changes when the user remembers less and less information about the desired history entry. The first example follows.}


\begin{verbatim}
# relevant history entries:
    cd git/thumbnail_api
    ssh root@thumbnail-api.dev.example.com
    scp root@thumbnail-api.dev.example.com:/log/thumbnail/1.log
    git commit -m "improve api logging"
    ...
    cd git/thumbnail_worker
    ssh root@thumbnail-worker-1.dev.example.com
    ssh root@thumbnail-worker-2.dev.example.com
    ssh root@thumbnail-worker-3.dev.example.com
    ...
    ssh 192.168.2.105
# desired command line entry:
ssh root@thumbnail-api.dev.example.com
\end{verbatim}

In the example above, the user wants to remotely log into a \verb|thumbnail api| server in the development environment using \verb|ssh|. 

If the user saw the full example in front of him as we do now, it would be quite easy to choose a good searching strategy. However, the user does not see, nor he remembers all the relevant information. He will need to make use of his limited memory to find the desired command line entry. 

A common way to search shell history is reverse search. The user initiates the reverse search by pressing \verb|CTRL-R| and types in the query \verb|thumbnail|. The resulting prompt is shown below.\footnote{The search result and the prompt should be on the same line. We moved them to separate lines because they would not fit the page otherwise.}
% Reverse search displays a single most recent history entry that matches the query 

\begin{verbatim}
(reverse-i-search)`thumbnail': 
    ssh root@thumbnail-worker-3.dev.example.com
\end{verbatim}

Here, we see that the \verb|thumbnail| query matched a history entry that is not very relevant. The user makes the query more specific by typing \verb|-api|.

\begin{verbatim}
(reverse-i-search)`thumbnail-api': 
    scp root@thumbnail-api.dev.example.com:/log/thumbnail/1.log
\end{verbatim}

The reverse search still does not show the desired history entry. However, it shows a result that is much closer to what the user is looking for. The user thinks that the query is specific enough and presses \verb|CTRL-R| to show the next search result.

\begin{verbatim}
(reverse-i-search)`thumbnail-api':
    ssh root@thumbnail-api.dev.example.com
\end{verbatim}

The next result is the desired history entry; The user can press \verb|ENTER| to execute it. This was a pretty efficient but also a quite idealistic reverse search example. It worked out so well because the user was able to provide a specific enough query -- \verb|thumbnail-api|. We should look at a more realistic situation where the user struggles to come up with such a query. 

\paragraph{Realistic example of reverse search}

In this example, we are using the same shell history and desired command line entry as in the previous example. Again, the user wants to remotely log in to a \verb|thumbnail api| server in the development environment using \verb|ssh|. He presses \verb|CTRL-R| and starts searching using \verb|ssh| as a query; It is very natural and quite common to use the beginning of the line as a query in reverse search.

\begin{verbatim}
(reverse-i-search)`ssh': ssh 192.168.2.105
\end{verbatim}

The most recent matched history entry does not look very promising. The user tries to extend the query to \verb|ssh thumbnail|.

\begin{verbatim}
(failed reverse-i-search)`ssh thumbnail': ssh 192.168.2.105
\end{verbatim}

Here, we see how the user struggles to make the query more specific; Extending the query requires knowledge of the details of the desired command line entry. The user does not remember that he should be logging in under \verb|root|. % It is exactly details like this one that we hope to retrieve from shell history so that we do not need to remember them. 

The user sees that the search has failed, and so he aborts it by pressing \verb|CTRL-C|. Then, he starts over by pressing \verb|CTRL-R|. He types \verb|thumbnail| as a query, hoping it will bring better results.


\begin{verbatim}
(reverse-i-search)`thumbnail':
    ssh root@thumbnail-worker-3.dev.example.com
\end{verbatim}

This result is an improvement over the previous one. However, it is still far from what we are looking for. The user should extend the query to make it more specific. 

Previously, we assumed that the user remembers enough to extend the query to \verb|thumbnail-api|; That is a bold assumption. What if the user does not remember that words \verb|thumbnail| and \verb|api| are adjacent or that they are delimited by a dash symbol? In practice, it is hard to come up with a query that only matches the desired history entry. Oftentimes, the query matches many other history entries, which forces us to go through multiple search results.


The user is in a similar situation. He presses \verb|CTRL-R| repeatedly to display the search results one by one. At first, the user presses \verb|CTRL-R| slowly to have enough time to read the results. After about three keypresses, he becomes impatient and speeds up. This does not leave enough time to properly read each of the results, which causes him to press \verb|CTRL-R| one too many times.

\begin{verbatim}
(reverse-i-search)`thumbnail': cd git/thumbnail_api
\end{verbatim}

The user knows that pressing \verb|CTRL-S| should bring back the previous result. However, he also knows that pressing \verb|CTRL-S| freezes all input coming to his terminal; This is the default\footnote{In default configuration on many popular distributions CTRL-S produces XOFF -- a software flow control sequence that stops all input coming to the terminal.} behaviour and he could never be bothered to find out how to fix it.

At this point, the user gets annoyed because the only option is to start over. He aborts the search, presses \verb|CTRL-R|, and types in the query \verb|thumbnail|. Then, it takes five presses of \verb|CTRL-R| to get to the desired result; This time he is more careful not to go too far again.


\paragraph{Limits of reverse search}

As we just saw, the reverse search is not always an effective way to search the shell history. It heavily relies on the ability of the user to form a single continuous query; A single query that is specific enough to match the desired history entry without matching many other history entries. 

This drawback is further amplified by only displaying a single result at a time. Showing multiple results at a time would make it easier to find the desired history entry in cases when there are many matching results. 

Despite these downsides, the reverse search is a quite popular way to search the shell history. Why do people use it, given the disadvantages we discussed? The reverse search is not without its flaws, but it is still the most powerful interactive way to search the shell history. %We suspect that many people simply use what is available by default.

If the reverse search is as bad as we claim, are there other alternatives that people choose to use instead? Another quite popular method people use is manual history filtering. Manual filtering searches the history non-interactively; It brings its own set of advantages and disadvantages, which we cover in the next section.


\paragraph{Manual history filtering}

As mentioned before, manual filtering is a popular non-interactive way to search the shell history. It can be used to fulfill similar workflows as the reverse search. To properly compare the two methods, we will use the same example as before. You can see the same relevant history entries with the same desired history entry below.


\begin{verbatim}
# relevant history entries:
    cd git/thumbnail_api
    ssh root@thumbnail-api.dev.example.com
    scp root@thumbnail-api.dev.example.com:/log/thumbnail/1.log
    git commit -m "improve api logging"
    ...
    cd git/thumbnail_worker
    ssh root@thumbnail-worker-1.dev.example.com
    ssh root@thumbnail-worker-2.dev.example.com
    ssh root@thumbnail-worker-3.dev.example.com
    ...
    ssh 192.168.2.105
# desired command line entry:
ssh root@thumbnail-api.dev.example.com
\end{verbatim}

As in the previous example, the user wants to remotely log in to the \verb|thumbnail| \verb|api| server in the development environment using \verb|ssh|. He uses the \verb|history| built-in to print the shell history together with the \verb|grep| command to filter the history entries.

First, he types \verb#history | grep ssh#; The output could look something like this.

\begin{verbatim}
$ history | grep ssh
...    ...
421    ssh root@thumbnail-api.dev.example.com
450    ssh root@thumbnail-worker-1.dev.example.com
451    ssh root@thumbnail-worker-2.dev.example.com
452    ssh root@thumbnail-worker-3.dev.example.com
489    ssh 192.168.2.105
\end{verbatim}


Using manual filtering displays all five matching history entries at the same time. The user can skim through the results looking for the desired history entry. 
After he finds the result, he can either copy and paste it using a mouse or can use history substitution.

The user found the desired history in the list and uses history expansion to execute it. He types \verb|!421| and presses \verb|ENTER|.

\begin{verbatim}
$ !421
    ssh root@thumbnail-api.dev.example.com
\end{verbatim}

This was pretty quick and efficient. However, what if there were more matching history entries? What if the user could not spot the desired history entry in the list of results?

In such a case, nothing prevents the user from further filtering the results. Pressing \verb|ARROW_UP| retrieves the previous command line entry, and typing \verb#| grep thumbnail# adds another query. He can repeat this until he is happy with the filtered results.

\begin{verbatim}
$ history | grep ssh | grep thumbnail | grep api
421    ssh root@thumbnail-api.dev.example.com
\end{verbatim}

Here, using three queries filtered out all history entries but the desired one.

\paragraph{Advantages of manual filtering}

We saw that manual filtering has some clear advantages over the reverse search.
First, skimming through the displayed results is relatively quick. This allows the user to use queries that are not very specific.
Even generic query like \verb|ssh| that was not specific enough for reverse search gave us some useful results when filtering manually.

Additionally, in a situation when the query is not specific enough, it is easy to combine multiple queries together. This makes manual filtering much more powerful than the reverse search. 
When using the reverse search, we had to choose between the queries. Here we can use all of them. This results in a very flexible workflow where we refine the search instead of guessing which single query we should use.


As we already mentioned earlier, manual filtering is a non-interactive history mechanism. This comes with an obvious disadvantage; To filter history manually, the user has to type extra characters \verb#history | grep# instead of simply pressing \verb|CTRL-R| to initiate the reverse search. In some situations, the reverse search might be a more effective way to search the history.




\subsection{Searching with implicit context}\label{workflow-search-w-implicit-context}
In the previous workflows, we saw that searching history heavily relies on the memory of the user. When the user does not remember enough, the efficiency of the standard history searching mechanisms is reduced.

Now, we consider situations where it is possible, at least partially, to replace the user's knowledge with other information. In the following examples, we will see how we could improve the shell history by using additional information such as exit status or current working directory.

\begin{verbatim}
# relevant history entries:        
    dd if=~/ubuntu.iso of=/dev/sdc bs=4M status=progress
    sudo dd if=~/ubuntu.iso of=/dev/sdc bs=4M status=progress
    dd if=~/manjaro.iso of=/dev/sdc bs=4M status=progress
    sudo dd if=~/manjaro.iso of=/dev/sdc bs=4M status=progress
\end{verbatim}

In this example, the user wants to use \verb|dd| to create a bootable USB drive from an ISO file. The user uses \verb|dd| as a search query. We are not considering a specific existing history mechanism. Instead, we discuss the possibilities and potential of shell history in this particular situation.

All of the history entries in the example match the query. However, not all of these history entries are useful. Two of the entries that do not start with \verb|sudo| will result in an error if executed\footnote{In this example, the user is not currently logged in as a superuser.}. 

In situations like this one, it could be useful if the history entries that originally ended with a zero status code were displayed before the ones that failed. Reordering search results could help the user to find the relevant results more quickly. 

\paragraph{Directory sensitive history}

In this next example, we look at the advantages of directory-sensitive history.

\begin{verbatim}
# relevant history entries:
    cd ~/git/image_server
    git pull
    vim pkg/encoder/encoder.go pkg/encoder/util.go
    make build
    make build && ./scripts/run_tests.sh --quick
    git commit -am "refactor encoding"
    ssh root@image-server-2.c137.dev.example.com
    ssh root@processing-node-13.c137.dev.example.com
    VERSION=2.4.2 make release
    git commit -am "release 2.4.2"
    git tag v2.4.2
    git push
    git push --tags
\end{verbatim}

Here, we see a section of shell history related to a specific project. The user executed all of the command line entries above a long time ago in the \verb|~/git/image_server/| directory. He did not work on the \verb|image_server| project since. This means that he does not remember these history entries. Plus, his history is filled with many other command line entries he executed since.

The user comes back to the project by typing and executing \verb|cd ~/git/| \verb|image_server|. He wants to continue working on the project. To do so he needs to edit some code, build the project, test it, and release a new version. However, he does not remember the specific command line entries for these tasks. 

Some of the command line entries he needs are easy to remember because they are generic. Examples of such entries are \verb|git pull| which pulls new changes from upstream, and \verb|make build| which build the project. However, some of the tasks require knowledge specific to this project. For example, it might take some effort to find out that running tests is done using \verb|./script/run_tests.sh|. Similarly, it is not obvious that \verb|VERSION| environment variable should be set when running \verb|make release|.

This information is stored in the shell history, but it is not easy to retrieve. Standard history mechanisms only search by the command line entry itself. It could be very useful if the user was able to display and search the history from the current directory.

\section{Existing history tools}

In this section, we take a look at popular existing history tools. Many of these tools relate to the workflows we identified earlier. We describe how these tools work, and we explain how they are useful to users. 

Most of the tools we cover can be used to enhance the capabilities of standard shell history. Apart from shell history tools, we also describe history features of other programs such as the Fish shell\cite{fishdocs} and the Python console in Blender\cite{tools-blender-docs-python-console}. Full list of tools we cover is the following:

\begin{itemize}
    \item Autosuggestions
    \item Forward in history
    \item Multi-query multi-result interactive history search
    \item Fuzzy history search
    \item Contextual shell history in the cloud
    \item Contextual history search powered by a neural network
\end{itemize}

\subsection{Autosuggestions}

The first history feature we discuss are autosuggestions. As you type on the command line autosuggestions suggest a single history entry that starts with characters you already typed. Figure \ref{fish-autosuggestions} shows the autosuggestions after the user typed \verb|ssh|; The suggested text is displayed in grey.


\begin{figure}[h!]
  \tmpframe{\includegraphics[width=\linewidth]{figures/existing-tools/xterm-fish-autosuggestions.pdf}}
  \caption{Fish shell autosuggestions}
  \label{fish-autosuggestions}
\end{figure}


This history feature is very quick and convenient to use. You can use the shell as you would normally do, with the option to accept the suggestion whenever it matches what you want to type. Autosuggestions can replace neither \verb|ARROW_UP| nor proper history search. However, they work well in combination with these and other history features.

Autosuggestions also have some interesting properties compared to stepping through history using \verb|ARROW_UP|.
When people use simple \verb|ARROW_UP| they often expect to retrieve immediately recent history entries\footnote{We described a specific workflow showing this in the previous section \ref{workflow-blind-retrieval}}. This is not the case with autosuggestions. %The displayed suggestion can be the most recent matching history entry, but it also does not have to be. 
Autosuggestions can use more experimental and more advanced recommendation techniques.

Autosuggestions were originally designed and developed as part of the Fish\cite{fishdocs} shell; These are context-sensitive suggestions that take the current directory into account. Upon command line execution, Fish shell checks if any parameter is a valid path and marks that in the shell history. Later, history entries are only suggested if all the marked parameters are valid paths\cite{toolsfishissueautosuggestions}.

There is also an implementation of autosuggestions available for Zsh\cite{toolszshautosuggestions}; Unlike its original version, this implementation does not offer context-sensitive suggestions. Another project\cite{toolszshhistdb} uses Zsh autosuggestions to offer history based on the current directory.
Unfortunately, there is no native nor ad-hoc support for autosuggestions in Bash. 

%In addition, based on our experience with Bash and its line-editing library Readline\cite{ramey2001gnureadline} implementing autosuggestions for Bash is likely impossible.


\subsection{Forward in history}

In standard shell history, we can access the previously executed history entries by pressing \verb|ARROW_UP|. Pressing \verb|ARROW_DOWN| can be used to get back to the original prompt.
As we saw in section \ref{workflow-repeating-a-sequence}, this behavior is quite inefficient when we want to retrieve a sequence of history entries.

Forward in history feature allows you to repeat sequences of command line entries efficiently. It overloads \verb|ARROW_DOWN| with a secondary functionality. 
By pressing \verb|ARROW_DOWN|, we can access entries from history that follows the command line entry we just executed. Essentially, when we retrieve and execute any history entry, we can use \verb|ARROW_DOWN| to retrieve more history entries that follow it. In other words, \verb|ARROW_DOWN| gives us access to the history relative to the previously executed history entry.

%\redtext{WIP MARKER}

%When you execute a command line entry and press \verb|ARROW_UP|, you get preceding history entries. In contrast, \verb|ARROW_DOWN| can give you access to following history entries.

%How does the history system know the future? First of all, the system needs to record full non-deduplicated sequential history. 

%Every command line entry in this full history is a part of a sequence. This means that there are specific preceding and following history entries for every command line submission. Whenever you retrieve a command line entry, the history entries that follow it in the history are available via \verb|ARROW_DOWN|.

% Pressing \verb|ARROW_DOWN| gives you quick access to the history entries that follow the history entry you just executed. 

Forward in history feature can be found in Python console in Blender \cite{tools-blender-docs-python-console}. This makes a lot of sense because every cycle and condition in Python console is a sequence. Naturally, using the Python console often includes workflows that require sequence repeating.

Arguably, using shell involves less sequence repeating than using a Python console in Blender. However, as we saw earlier in section \ref{workflow-repeating-a-sequence}, it is still a relevant workflow that is not well supported by the standard shell history mechanisms. 

\subsection{Multi-query multi-result interactive history search}

When we talked about history reverse search, we identified two issues with it. First, it only allows using a single query for searching. Second, it only displays a single result.
Searching history manually does not have these issues. However, it is a non-interactive history feature, and it requires additional typing. 

Hstr\cite{toolshstr} is an interactive history searching tool that addresses both of the issues we identified with the reverse search. Unlike manual history filtering, it does not require the extra typing. Hstr is designed to be bound to \verb|CTRL-R| with an intention to fully replace the reverse search.

When launched, it displays a full-screen terminal application, as shown in figure \ref{hstr-screenshot}. You type a query at the top, and a page of matching history results is displayed below. In the default "keywords" matching mode, each word of the query is used as a separate searching term. 
In addition to the default "keywords" matching mode, there are also "exact" and "regexp" matching modes. 
Hstr is quite popular\footnote{Hstr has over two thousand stars and over eight thousand downloads on GitHub.} on GitHub, where it is hosted. Some of the people who use Hstr describe it as life-changing.


\subsection{Fuzzy history search}

Fzf\cite{tools-fzf} is a popular\footnote{Fzf has over 28 thousand stars on GitHub.} general-purpose command line fuzzy finder. The documentation of the project recommends several ways that can be used to interactively search shell history.

Searching history using Fzf addresses the issues of the history reverse search. 
As shown in figure \ref{fzf-screenshot}, Fzf can display a full page of results from history. 

Fuzzy search allows Fzf to retrieve both exactly and approximately matching history entries. Exact and close matches are returned first, and fuzzy matches are returned after. 
This behavior essentially provides the functionality of a multi-query search. In addition, fuzzy search can match the desired history result even when you make typos in the query. Unlike "keywords" matching in Hstr, fuzzy matching is tolerant to mistakes and typos; Naturally, this is very appealing to users. 

\begin{figure}[h!]
  \permanentframe{\includegraphics[width=0.995\linewidth]{figures/existing-tools/xterm-hstr-std.pdf}}
  \caption{Hstr interactive history search}
  \label{hstr-screenshot}
\end{figure}

\begin{figure}[h!]
  \permanentframe{\includegraphics[width=0.995\linewidth]{figures/existing-tools/xterm-fzf-std.pdf}}
  \caption{Searching history interactively using Fzf}
  \label{fzf-screenshot}
\end{figure}

Fuzzy search is a commonly requested feature in various history tools. Some people who are already using Fzf cannot imagine using history tools without a fuzzy search.

\subsection{Contextual shell history in the cloud}


Bashhub\cite{toolsbashhubclient} saves your shell history to the cloud and allows you to search it from all of your machines.

Apart from the command line entry, Bashhub records and saves additional context. Each history record contains following:
\begin{itemize}
    %\setlength\itemsep{0em}
    \item command line entry
    \item exit status
    \item present working directory
    \item host
    \item time of execution
    \item ID of the session
    \item ID of the record
\end{itemize}

The Bashhub history search uses pattern matching\footnote{The pattern matching is implemented using SQL "LIKE" operator.} to search the submitted command line entries. The search can be restricted to the current directory and to the current host.


All searching is server-side; This means that every time you search your history using Bashhub, it needs to send a request to a remote server.
These requests take time, so there is no interactive "search as you type" functionality. Instead, you always have to type out the full query, execute the search command, and then wait for the results. Below, you can see an example of a search command that is restricted to the current directory. 

\begin{verbatim}
bh -d "curl git"
\end{verbatim}

An obvious disadvantage of a server-side search is that it does not work offline. 
When you use Bashhub, your history is saved on the remote server, and the server needs to be able to search it. This means that the history is on the server, at least in memory, in an unencrypted form. Adding client-side encryption would break the server-side search.

By default, the remote server is an instance maintained by the project author. The official server implementation is closed source. This means that you need to trust the author of the project with access to your shell history. 

Recently\footnote{Open source implementation of Bashhub server was written in February 2020.} a new open-source implementation\cite{toolsbashhubserver} of the Bashhub server has appeared. This addresses the privacy and security issues by making it possible to run and use your own instance of the server.

%\redtext{Bashhub is somewhat popular on GitHub\footnote{Bashhub has 744 "stars" on GitHub.}
%Bashhub is not a viable replacement for standard reverse search and manual history searching.}

\subsection{Contextual history search powered by a neural network}

McFly\cite{toolsmcfly} is a tool that tries to predict your next command line entry using a small neural network. It predicts the next command line entry based on the following contextual information:
\begin{itemize}
    \item present working directory
    \item previous command line entries
    \item how often you run the command line entry
    \item the last time you ran the command line entry
    \item if you selected the command line entry in McFly before
    \item exit status
\end{itemize}

Unlike Bashhub, this tool is designed to be bound to \verb|CTRL-R| and to replace the standard reverse search. Pressing \verb|CTRL-R| launches McFly full-screen terminal app shown in figure \ref{tools-mcfly}. At first, the app displays a list of ten predicted history entries. The list of history entries is updated as you type; It only shows results that exactly match the typed query. The list always contains ten results or less, which is a curious design decision. 


\begin{figure}[h]
  \permanentframe{\includegraphics[width=0.995\linewidth]{figures/existing-tools/xterm-mcfly-std-short.pdf}}
  \caption{McFly interactive history search (cropped)}
  \label{tools-mcfly}
\end{figure}


When trying to use McFly, we found its behavior to be unpredictable; Not knowing why specific results are being shown made the tool less useful. 

McFly shares some problems with reverse search; It only uses a single query for searching. This can make it hard to find what you need in situations when you are unable to think of a better query\footnote{We already described such a situation in section \ref{workflow-search-w-limited-knowledge}}. 

%\redtext{McFly is popular on GitHub.\footnote{McFly has about sixteen hundred "stars" on GitHub.}}

%\begin{figure} \permanentframe{\includegraphics[width=0.995\linewidth]{figures/existing-tools/xterm-mcfly-full.pdf}} \caption{McFly interactive history search \redtext{REMOVE IMAGE}} \end{figure}


\section{Usefulness of contextual information}

In the previous section, we talked about existing history tools. We saw that contextual history tools are not automatically more useful than tools that do not work with additional context. 

Useful history tools address real workflows and provide value to the user.
In this section, we explore available contextual information. We will discuss how different parts of the context relate to shell usage and history usage. %We do this to identify the usefulness of different parts of available contextual information. 
We cover the following parts of the available contextual information:

\begin{itemize}
    \item Exit status
    \item Directory and Git related context
    \item Sequential relationships, sessions, and time
    \item Host and portability of history entries
    \item Usage of history features
\end{itemize}

\subsection{Exit status}

The shell interprets zero exit status as success. In contrast, non-zero status indicates failure.\cite{bashman} People often immediately edit and resubmit command line entries that returned an error. However, people probably rarely want to repeat older command line entries that failed. Does this mean that we can use exit status to filter out errors and only serve successful history entries to the user?

Not really, exit status does not directly map to success and failure. Programs can fail without returning an error. Some programs return non-zero exit status without actually failing\footnote{For example, GNU Grep returns one when no lines were matched and two to indicate errors.\cite{man-grep}}. 
Additionally, even history entries that are technically errors can be useful to the user. For example, the user might interrupt a program using \verb|CTRL-C| after it has fulfilled its purpose.

Generally, it is reasonable to assume that people retrieve history entries with zero exit status more often than the ones with errors. However, given the caveats described above, we should exercise this assumption conservatively. Removing history entries based on exit status would prevent the user from retrieving them. To preserve this ability, we can display all history entries but prioritize the successful ones.

\subsection{Directory and Git related context}

Directories provide explicit context. People change into different directories to complete different tasks.\cite{greenberg1993computer} It is often more comfortable to change directories compared to using longer paths as arguments. 

Many standard tools encourage the user to use specific directories for specific tasks. 
For example, Makefile, Vagrantfile, and Dockerfile are all designed to be used from within their directory\cite{man-make}\cite{docs-vagrantfile}\cite{docs-dockerfile}. 

Directories often hold projects that are associated with specific workflows and command line entries. 
These projects often use Git or other version control systems. This almost forces the user to use command line entries specific to the project inside the version control repository. 

We should make it easy to access the history entries from the present working directory.
However, we do not have to stop there. Directories and Git repositories are closely related, but they are not quite equivalent. Git provides some more context we can use. 
%The goal is to differentiate between history entries executed inside and outside the Git repository. 
Root of the Git repository allows us to group all history entries from the Git repository.
Git remotes\footnote{Remotes are remote repositories tracked by Git. Origin is the default remote.} can be used to identify the repository even across different machines or when it is moved to a different directory. 




\subsection{Sequential relationships, sessions, and time}

Command line entries are generally not executed individually; They are a part of longer sequences and tasks.\cite{greenberg1993computer} Each entry is related to its preceding and following command line entries. 

While analyzing shell history we collected from people, we observed significant sequential dependencies between command stubs. These dependencies represent workflows that users recognize and remember.\footnote{Analysis of sequential dependencies between history entries can be found in an appendix in section \ref{seq-app}.}

Apart from immediate sequential dependencies, each command belongs to a terminal session. We have observed significant differences between how people use sessions. Some people often create new terminals even for a few command line entries and then close them. Others keep terminals open for a long time and reuse them for different tasks.
Additionally, people very often switch back and forth between multiple open terminals. Command line entries from simultaneous terminal sessions are usually different but all related to the same task.

These relationships between history entries and sessions are definitely interesting and possibly useful. To illustrate, imagine you type a command line entry that you already executed five times in the past. Maybe it is related to a specific task, and to complete it, you will need similar commands as before. Situations like this one show us the potential usefulness of session and history entry relationships.

However, it is not apparent if these relationships are general enough to be useful in the average case. It is unclear how to use this complex contextual information to provide value to the user. It is beyond the scope of this work to study the relationships between history entries and between sessions.

Nevertheless, not all of the sequential contextual information is difficult to interpret and use. Sequences of history entries are useful because there are situations when people want to repeat them.\footnote{We have described such a situation in section \ref{workflow-repeating-a-sequence}.} We should support such workflows.

One more use for sequences of command line entries is recording them as a full non-deduplicated transcript. Having a full transcript of your actions gives you the ability to refer back to what you were doing earlier. A transcript of command line entries should also include the time of execution for the individual entries.

\subsection{Host and portability of history entries}

Imagine that you have your shell history synchronized between multiple devices.
Each of the devices is at least slightly different, so it is a good idea to be able to tell them apart. Devices usually have hostnames which we can use to identify them. 

Since each device can be different, we should look at the possible differences that are relevant to the shell history. Different operating systems use different package managers to install software. For example, Debian-based distributions use Apt, Arch-based distributions use Pacman, and on MacOS users use Homebrew. Commands for one package manager will not work with the others.

Many history entries are valid in both Bash and Zsh, but not all history entries. Shell configuration might differ between devices, which could cause some history entries to not work properly on all devices. A good example are specific shell aliases that the user added to one of their devices.

We just described why some history entries would not work when executed from a different device. Some history entries might not work even when executed on the same device but out of the original context. Examples of this are shell variables and relative paths. Variables that were set at the time of execution can cause history entries to fail when retrieved and executed again. History entries with relative paths will only work in specific directories.

As we can see, there are many reasons why history entries might not be portable. Most of the issues above can be detected using relevant contextual information. 
We could detect and handle these portability issues individually. Or alternatively, we could take a more straightforward approach; Prioritize history entries from the current device over those from other devices. This could be an effective strategy because many of the portability issues are related to mixing shell history from different devices. 

\subsection{Usage of history features}

So far, we have only described context related to the usage of shell and to the device. Now we look at the context that is related to how people use shell history. 

The first step is to know which command line entries are typed and which are retrieved from history. 
According to \cite{greenberg1993computer}, people tend to repeatedly retrieve the same events from history.

Next, we want to know which history feature was used to retrieve the entry. Knowing if the user used \verb|ARROW_UP| or \verb|CTRL-R| to retrieve a history entry allows us to separately study and evaluate these history mechanism. Different history features are used to complete different workflows; We should not treat them all as one.

%For example, when you retrieve a specific history entry using \verb|CTRL-R|, you are more likely to retrieve it using \verb|CTRL-R| again in the future.\footnote{We have observed that in collected usage data that retrieval of already retrieved history entries accounts for more searches than searching for the first time.}  

%This is supported by previous research; According to Greenberg, it should be it easy to retrieve history entries that were already retrieved earlier.\cite{greenberg1993computer}

A detailed transcript of user interactions with the history mechanisms would give us even more useful information. Consider a situation where the user presses \verb|ARROW_UP| ten times and then gives up and uses \verb|CTRL-R| to search the history instead. This is not an effective way to use history. However, it would be wrong to blame the user. If such a situation happens a lot to many users, we should look into if we can redesign \verb|ARROW_UP| to improve it.

The interactions between the user and the history features can help us understand how people use history. Knowing how people use standard shell history and our history solution is essential for informing design decisions. It is also crucial for evaluating the performance and usefulness of the final solution. %Interactions can help us understand when the system works and when it does not.
